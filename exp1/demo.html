<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Experiment 1 - Three.js Demo</title>
  <style>
    html {
      height: 100%;
    }

    body {
      max-height: 100%;
      margin: 0;
      background-color: black;
      color: white;
      overflow: hidden;
    }

    h1 {
      padding: 10pt;
      /* text-align: center; */
    }

    #page-texts {
      padding: 10pt;
      /* text-align: center; */
    }

    button.inactive {
      background-color: black;
      border-color: darkgray;
      /* border: 1pt; */
      color: darkgray;
    }

    button.active {
      background-color: goldenrod;
      color: white;
    }
  </style>
</head>

<body>
  <h1>Experiment 1 Demo by <em>Xie Haotong</em></h1>
  <div id="page-texts">
    <p><b>Instruction: </b></p>
    <p>Hit the <b>'M'</b> key or click the buttons to switch bewteen materials;</p>
    <p>Drag the mouse to control the perspective.</p>
    </p>
    <br>
    <p><b>Material: &nbsp;</b>
      <span id="span-materials">
        <button id="normal" class="active" onclick="switchMat('normal')">Normal</button>
        <button id="metal" class="inactive" onclick="switchMat('metal')">Metal</button>
        <button id="celluoid" class="inactive" onclick="switchMat('celluoid')">Celluiod</button>
      </span>
    </p>
  </div>

  <div id="scene-top"></div>
</body>

<!-- THREE.js Library -->
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>

<!-- shaders -->
<script id="normal-vs" type="text/glsl">
  // passed from param
  uniform vec3 light;
  
  // pass to fs
  varying vec3 vNormal;
  varying vec3 vLight;
  
  void main() {
    // normal vector
    vNormal = normalize(normalMatrix * normal);
    
    vec4 viewLight = viewMatrix * vec4(light, 1.0);
    vLight = viewLight.xyz;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
</script>
<script id="normal-fs" type="text/glsl">
  uniform vec3 color;

  varying vec3 vNormal;
  varying vec3 vLight;
  
  void main() {
    float diffuse = dot(normalize(vLight), vNormal);
    gl_FragColor = vec4(color * diffuse, 1.0);
  }
</script>
<script id="celluoid-fs" type="text/glsl">
  uniform vec3 color;

  varying vec3 vNormal;
  varying vec3 vLight;
  
  void main() {
    float diffuse = dot(normalize(vLight), vNormal);
    if (diffuse < 0.2) {
      diffuse = 0.2;
    } else if (diffuse < 0.4) {
      diffuse = 0.4;
    } else if (diffuse < 0.6) {
      diffuse = 0.6;
    } else if (diffuse < 0.8) {
      diffuse = 0.8;
    } else {
      diffuse = 1.0;
    }
    gl_FragColor = vec4(color * diffuse, 1.0);
  }
</script>
<script id="metal-fs" type="text/glsl">
  uniform vec3 color;

  varying vec3 vNormal;
  varying vec3 vLight;
  
  void main() {
    float diffuse = dot(normalize(vLight), vNormal);
    if (diffuse > 0.0) {
      gl_FragColor = vec4(color * diffuse * diffuse, 1.0);
    } else {
      gl_FragColor = vec4(abs(color * diffuse) * 0.5, 1.0);
    }
    
  }
</script>

<!-- Three.js page rendering -->
<script id="renderer" type="text/javascript">
  var canvasHeight = window.innerHeight - document.getElementById("scene-top").offsetTop;
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(document.body.clientWidth, canvasHeight);
  // renderer.setClearColor(0x000000);
  document.body.appendChild(renderer.domElement);


  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth / canvasHeight, 1, 100);
  camera.position.set(-1, 1, 10);

  // light
  // scene.add(new THREE.AmbientLight(0x222222));
  const pointLight = new THREE.PointLight(0xFFFFFF);
  pointLight.position.x = 23;
  pointLight.position.y = 34;
  pointLight.position.z = 45;
  camera.add(pointLight);

  // showing axis
  scene.add(new THREE.AxesHelper(10));

  // mousing controls
  var controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.update();

  // create a material with custom shader
  function createMaterial({ vs = "normal-vs", fs = "normal-fs" } = {}) {
    return new THREE.ShaderMaterial({
      uniforms: {
        color: { type: 'v3', value: new THREE.Color(0x00dddd) },
        light: { type: 'v3', value: pointLight.position },
      },
      vertexShader: document.getElementById(vs).innerHTML,
      fragmentShader: document.getElementById(fs).innerHTML,
      transparent: false
    });
  }

  // a regular sphere at first
  var sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), createMaterial({ fs: "normal-fs" }));
  scene.add(sphere);

  // loop
  function update() {
    renderer.render(scene, camera);
    controls.update();
    requestAnimationFrame(update);
  }

  requestAnimationFrame(update);

  // listening 'S' key
  var mats = ['normal', 'metal', 'celluoid'];
  var matid = 0;
  document.onkeypress = (event) => {
    if (event.key == 'm') {
      switchMat(mats[++matid % mats.length]);
    }
  }
  // functions to handle butttons:
  function activateMatBtn(activeid) {
    var childs = document.getElementById('span-materials').childNodes;
    for (const c of childs) {
      if (c.nodeName == 'BUTTON' && c.className == 'active' && c.id != activeid) {
        c.className = 'inactive';
      }
    }
    document.getElementById(activeid).className = 'active';
  }
  function switchMat(mat) {
    activateMatBtn(mat);
    sphere.material = createMaterial({ fs: mat + '-fs' });
    matid = mats.findIndex(m => { return m == mat });
    sphere.material.needsUpdate = true;
  }

  window.onresize = () => {
    canvasHeight = window.innerHeight - document.getElementById("scene-top").offsetTop;
    camera.aspect = window.innerWidth / canvasHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, canvasHeight);
  }
</script>

</html>